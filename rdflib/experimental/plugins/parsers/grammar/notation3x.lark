// EBNF grammar for Notation3
start:                      (statement "." | sparqldirective)*
statement:                  directive | forall | triples
directive:                  prefixid | base
prefixid:                   "@prefix" PNAME_NS IRIREF
base:                       BASE_DIRECTIVE IRIREF // "."
sparqldirective:            sparqlbase | sparqlprefix
sparqlbase:                 BASE IRIREF
sparqlprefix:               PREFIX PNAME_NS IRIREF
triples:                    subject predicateobjectlist?
predicateobjectlist:        verb objectlist (";" (verb objectlist)?)*
objectlist:                 object ("," object)*
verb:                       predicate | "a" | "has" expression | "is" expression "of" | "="| "<="| "=>"
subject:                    expression
predicate:                  (expression | "<-" expression) // allow inverting first predicate in a path
object:                     expression
expression:                 path
path:                       pathitem ("!" path | "^" path)?
pathitem:                   iri | blanknode | quickvar | collection | blanknodepropertylist | literal | formula
literal:                    rdfliteral | numericliteral | booleanliteral
blanknodepropertylist:      "[" predicateobjectlist "]"
collection:                 "(" object* ")"
numericliteral:             INTEGER | DECIMAL | DOUBLE
booleanliteral:             "true"| "false"| "@true"| "@false"
formula:                    "{" formulacontent? "}"
formulacontent:             statement ("." formulacontent?)? | sparqldirective formulacontent?
rdfliteral:                 astring (LANGTAG | "^^" iri)?
astring:                    STRING_LITERAL_QUOTE | STRING_LITERAL_SINGLE_QUOTE | STRING_LITERAL_LONG_SINGLE_QUOTE | STRING_LITERAL_LONG_QUOTE
iri:                        IRIREF | prefixedname
prefixedname:               PNAME_NS | PNAME_LN // PNAME_NS will be matched for ":" (i.e., "empty") prefixednames hence this cannot be a lexer rule; for s/p/o of only ":", PNAME_NS will be returned instead of PrefixedName token
blanknode:                  BLANK_NODE_LABEL | ANON
quickvar:                   QUICKVAR_NAME // only made this a parser rule for consistency (all other path-items are also parser rules)
//forall:                     "@forAll" prefixedname "," prefixedname "," prefixedname EOL?
forall:                     "@forAll" prefixedname "," prefixedname "," prefixedname
forsome:                    "@forSome" prefixedname "," prefixedname "," prefixedname


// N3X extensions
n3x_expression:             or_expression
or_expression:              (and_expression ("||" and_expression)*)
and_expression:             (relational_expression ("&&" relational_expression)*)
relational_expression:      (additive_expression (("==" | "!=" | "<" | ">" | "<=" | ">=") additive_expression | "IN"  collection | "NOT" "IN"  collection)?)
additive_expression:        (multiplicative_expression (("+" | "-") multiplicative_expression)*)
multiplicative_expression:  (unary_expression (("*" | "/") unary_expression)*)
unary_expression:           (("!" | "+" | "-")? primary_expression)
primary_expression:         ( "(" n3x_expression ")" | function_call | n3_term)
function_call:              ((built_in | iri) arg_list)
arg_list:                   ("(" (n3x_expression ("," n3x_expression)*)? ")")
built_in:                   ("STR")  // to be completed


// terminals
BASE: ("B"|"b") ("A"|"a") ("S"|"s") ("E"|"e")
PREFIX: ("P"|"p") ("R"|"r") ("E"|"e") ("F"|"f") ("I"|"i") ("X"|"x")
BASE_DIRECTIVE: "@base"
IRIREF: "<" (/[^\x00-\x20<>"{}|^`\\]/ | UCHAR)* ">"
PNAME_NS: PN_PREFIX? ":"
PNAME_LN: PNAME_NS PN_LOCAL
BLANK_NODE_LABEL: "_:" (PN_CHARS_U | /[0-9]/) ((PN_CHARS | ".")* PN_CHARS)?
LANGTAG: "@" /[a-zA-Z]+/ ("-" /[a-zA-Z0-9]+/)*
INTEGER: /[+-]?[0-9]+/
DECIMAL: /[+-]?[0-9]*/ "." /[0-9]+/
DOUBLE: /[+-]?/ (/[0-9]+/ "." /[0-9]*/ EXPONENT | "." /[0-9]+/ EXPONENT | /[0-9]+/ EXPONENT)
EXPONENT: /[eE][+-]?[0-9]+/
STRING_LITERAL_QUOTE: "\"" (/[^\x22\\\x0A\x0D]/ | ECHAR | UCHAR)* "\""
STRING_LITERAL_SINGLE_QUOTE: "'" (/[^\x27\\\x0A\x0D]/ | ECHAR | UCHAR)* "'"
STRING_LITERAL_LONG_SINGLE_QUOTE: "'''" (/'|''/? (/[^'\\]/ | ECHAR | UCHAR))* "'''"
STRING_LITERAL_LONG_QUOTE: "\"\"\"" (/"|""/? (/[^"\\]/ | ECHAR | UCHAR))* "\"\"\""
UCHAR: "\\u" HEX~4 | "\\U" HEX~8
ECHAR: "\\" /[tbnrf"'\\]/
WS: /[\x20\x09\x0D\x0A]/
ANON: "[" WS* "]"
QUICKVAR_NAME: "?" PN_LOCAL
PN_CHARS_BASE: /[A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\U00010000-\U000EFFFF]/
PN_CHARS_U: PN_CHARS_BASE | "_"
PN_CHARS: PN_CHARS_U | /[\-0-9\u00B7\u0300-\u036F\u203F-\u2040]/
PN_PREFIX: PN_CHARS_BASE ((PN_CHARS | ".")* PN_CHARS)?
PN_LOCAL: (PN_CHARS_U | ":" | /[0-9]/ | PLX) ((PN_CHARS | "." | ":" | PLX)* (PN_CHARS | ":" | PLX))?
PLX: PERCENT | PN_LOCAL_ESC
PERCENT: "%" HEX~2
HEX: /[0-9A-Fa-f]/
PN_LOCAL_ESC: "\\" /[_~\.\-!$&'()*+,;=\/?#@%]/
EOL: /[\r\n]/+
COMMENT: "#" /[^\n]/*

%ignore WS
%ignore COMMENT
